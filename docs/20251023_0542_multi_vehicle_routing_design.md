# 複数車両による資源別ルート最適化 設計

## 1. 背景と課題
- 現行システムは **単一車両** で全回収資源を処理する前提で設計している。
- 車両互換性チェックは「全資源に対応できる車種が存在するか」を判定し、存在しなければ警告を出して処理を中断する (`src/app.py` の `_filter_vehicle_records`)。
- 現実には資源種別ごとに積載要件や規制が異なり、**複数車種を併用**して回収するケースが多い。
- 要望: 最小コストを維持しつつ、資源ごとに複数車種を組み合わせたルートを自動算出する。

## 2. 要求仕様
1. 一度に複数資源を選択した場合、まず「単一車両で全資源を運べるか」を判定する。
2. 不可能な場合は、必要な資源をカバーできる**最小コストの車種組み合わせ**を探索し、それぞれの車両でルート最適化を行う。
3. 車両は同一車種を複数台投入できるものとし、固定費は台数分計上する。
4. 最適化結果は車両ごとに表示し、総コストおよび資源別コスト内訳を集計する。
5. UI では「どの地点がどの車両に割り当てられたか」を確認できるようにする。

## 3. 全体アーキテクチャ変更概要

| コンポーネント | 変更概要 |
| --- | --- |
| UI (Streamlit) | - 資源互換性エラーを情報/選択 UI に置き換え。<br>- 車両ごとのルート結果・コスト表を表示。<br>- マニュアル編集 UI も複数車両前提で強化。 |
| `VehicleCatalog` | - 車種ごとのサポート資源一覧を保持。<br>- 複数台インスタンスを `VehicleInstance` として生成。 |
| 最適化 (`optimizer.py`) | - 単一車両 `Solution` から、複数台を保持する `FleetSolution` へ拡張。<br>- OR-Tools を複数車両モードで構成、または資源グループごとに個別実行し総合スコアを計算。 |
| `compatibility` モジュール | - 資源-車種互換性をグラフとして評価し、組み合わせ最適化の入力に利用。 |
| コスト集計 | - 台数分の固定費加算、車両ごとの距離コストを合算。 |

## 4. 車両組み合わせ探索ロジック

### 4.1 入力定義
- R: 選択された資源種別集合 (回収地点に基づく)
- V: 利用可能な車種集合 (UI 登録 or マスタ)
- `supports(v) ⊆ R`: 車種 v が運搬可能な資源集合
- `pickups(r)`: 資源 r に紐づく回収地点リスト (量・位置)

### 4.2 単一車両判定
1. `supports(v)` が `R` を包含する車種が存在すれば、従来通り v の単体ルート最適化を実行。
2. 複数存在する場合は、
   - (a) 走行距離見積もりに基づく固定費+変動費が最小の車種を選択、
   - (b) もしくは後述の組み合わせ探索に含めて比較 (実装時の選択)。

### 4.3 複数車両組み合わせ (セットカバー)
- 資源をカバーする車種集合 S を見つける問題を **重み付き集合被覆問題** としてモデル化。
- 目的: `min Σ cost(v_i)` subject to `⋃ supports(v_i) ⊇ R`。
- コストには以下を加味する：
  - 年間固定費 or 固定費換算値 (既存 `fixed_cost_per_km` 指標 × 想定距離)
  - 初期ルート距離の概算 (例えば資源ごとの巡回距離の上界) を加えた推定総コスト。

#### 近似戦略
1. **ILP アプローチ**: 小規模 (資源種別 ≤ 10、車種 ≤ 10 程度) なら、`binary x_v` を用いた線形計画で厳密解が得られる。
2. **貪欲近似**: `cost(v) / coverage_gain` によるヒューリスティックで、逐次最好スコア車種を選択。
3. **互換性グループ化**: 資源ノード同士が「共通車種を持つ」場合に連結成分へ分解し、成分ごとに車種選択を行う。

推奨は **ILP + フォールバック貪欲**。ILP が解けない場合 (timeout) は貪欲で近似解を採用する。

### 4.4 車両重複投入
- 同一車種を複数台投入する場合は、ILP 変数を `x_{v,k}` (k=1..max_fleet_v) として扱うか、貪欲で選択した際に必要台数を計算。
- 基本ルール: 回収資源セットを複数車両間で分割し、資源単位で担当を分ける。

## 5. ピックアップ割り当て

1. 車種集合が決定したら、各資源 (または資源グループ) を対応車両に割り当て。
2. 割り当て方法:
   - 車種 v がカバーする資源集合に対し、対応するピックアップをサブセット化。
   - 一資源を複数車両で分割する必要がある場合（容量不足）は、需要量に応じて複数ルートに分割。
3. 結果として、`Assignment = { vehicle_instance_id: [pickup ids] }` を構築。

## 6. ルート最適化フロー拡張

1. `FleetSolution` データクラスを新設:
   ```python
   @dataclass
   class VehicleRoute:
       vehicle: VehicleType
       pickups: List[str]
       solution: Solution  # 既存の単一路線解

   @dataclass
   class FleetSolution:
       routes: List[VehicleRoute]
       total_cost: float
       cost_breakdown: Dict[str, float]  # 固定費合計、距離費合計など
   ```
2. `_solve_with_ortools` / `_solve_simple` は単一ルート解を返す helper とし、フリート全体は新しい `solve_fleet_routing` が管理。
3. `solve_fleet_routing` は以下を実行:
   - 資源カバー ILP により車両セット決定。
   - ピックアップ割り当て (`assign_pickups_to_fleet`).
   - 各車両について既存ソルバーを呼び出し。
   - コストを集約し、`FleetSolution` を返す。
4. UI は `FleetSolution` を受け取り、車両ごとの地図表示・テーブルを生成。

## 7. UI 変更案
- **選択状況パネル**: 資源ごとの割り当て車種を表形式で表示。
- **車両別結果タブ**: 各車両のルート、距離、コスト明細を個別に提示。
- **警告・情報**: 資源カバー不可の場合は、利用者に追加車種の登録を促すメッセージへ変更。
- **編集 UI**: 手動で資源→車両の割り当てを調整できる余地を用意 (将来拡張)。

## 8. データ構造・保存
- `session_state` に以下を追加:
  - `fleet_assignments`: 車両別ピックアップ割当てキャッシュ
  - `fleet_solution`: 直近の `FleetSolution`
  - `resource_vehicle_plan`: ILP / 貪欲結果の記録
- JSON 出力 (将来): 複数車両案件のレポート拡張を想定。

## 9. スケジュールおよび実装ステップ案
1. 互換性エラーハンドリングを `resource_vehicle_plan` へ変更 (UI 側準備)。
2. 車両互換性グラフ作成と ILP/貪欲ロジックの実装 (services 層)。
3. `FleetSolution` の定義と最適化フローを段階的に適用。
4. テーブル・地図表示を複数車両対応へ刷新。
5. テストケース拡充 (資源×車両パターン、複数ルート生成)。

## 10. リスクと留意点
- OR-Tools 複数車両ルーティングを利用する場合、容量制約・走行ルートの交差など追加要件の整理が必要。
- ILP モデルは小規模を想定。INPUT が大きくなる場合はヒューリスティックやキャッシュ戦略が必須。
- UI の操作性を維持するため、モーダルや結果表示の更新に伴う性能に注意。
- コストの算出方法 (固定費換算距離の前提) を利用者に明示すること。

