# UI使いやすさ改善 詳細設計書

## 1. 背景と目的

### 1.1 背景
現在の資源回収ルート最適化ツールは、OR-Toolsによる最適化機能やOSMネットワークとの統合など、強力なコア機能を備えているが、ユーザーインターフェースにおいて以下の課題が確認されている。

- 重要な情報が縦長のページに分散しており、全体像の把握が困難
- 操作フローが複雑で、入力漏れや操作ミスが発生しやすい
- 視覚的フィードバックが不足しており、現在の状態や次のアクションが不明確
- エラーや警告が事後的にしか分からず、修正コストが高い

### 1.2 目的
本設計書は、**既存機能を一切崩さずに**UIの使いやすさのみを改善することを目的とする。

**主要目標**:
1. 情報アーキテクチャを整理し、認知負荷を軽減する
2. 操作フローを単純化し、直感的な操作を可能にする
3. 視覚的フィードバックを強化し、状態把握を容易にする
4. リアルタイム検証により、エラーを事前に防止する

### 1.3 スコープ
- **対象**: `src/app.py`のStreamlit UI部分のみ
- **非対象**: サービス層・インフラ層のロジック、最適化アルゴリズム
- **制約**: 既存の全機能を保持、データフロー・セッション状態の互換性維持

---

## 2. 現状分析

### 2.1 問題点の分類と詳細

#### 【A】情報アーキテクチャの問題

**A-1: 選択状況の視認性低下**
- **現状**: app.py:1130-1137で `st.write` で辞書を表示
- **問題**: スクロールしないと見えない、視覚的に目立たない
- **影響**: ユーザーが現在の設定を把握できず、入力漏れが発生

**A-2: 車種設定の配置**
- **現状**: app.py:258-307でページ中央に配置
- **問題**: 地点選択と車種設定が同じ画面レベルで混在
- **影響**: 作業フローが不明確、認知負荷が高い

**A-3: 警告メッセージの分散**
- **現状**: app.py:1186-1187など、処理ごとに個別表示
- **問題**: 問題の全体像が把握できない
- **影響**: 一部のエラーを修正しても、別のエラーで実行失敗

#### 【B】操作フローの複雑さ

**B-1: 回収地点の二重管理**
- **現状**:
  - 地図クリック → ダイアログ入力（app.py:764-862）
  - その後、下部で再編集（app.py:309-386）
- **問題**: 同じデータを2箇所で管理、整合性が不明確
- **影響**: ユーザーが混乱、編集場所を探す時間が増加

**B-2: 削除操作の複雑さ**
- **現状**: multiselect選択 → 削除ボタン押下の2ステップ（app.py:1108-1124）
- **問題**: 各地点に削除ボタンがない、一括削除のみ
- **影響**: 1箇所だけ削除したい場合も煩雑

**B-3: 手動選択UIのアクセス性**
- **現状**: エクスパンダーがデフォルトで閉じている（app.py:1140）
- **問題**: 手動調整が必要な場面でも気づかれない
- **影響**: 地図クリックでの微調整が困難な場合に対処できない

#### 【C】視覚的フィードバックの不足

**C-1: クリックモードの明示性**
- **現状**: ラジオボタンのみ（app.py:1049）
- **問題**: 現在のモードが何を意味するか説明がない
- **影響**: 誤ったモードで操作、期待と異なる動作

**C-2: 車種割当プランの隠蔽**
- **現状**: エクスパンダー内に格納（app.py:1189-1197）
- **問題**: 重要な割当情報が隠れている
- **影響**: 最適化前に割当を確認できず、容量不足などに気づけない

**C-3: 地図凡例の弱さ**
- **現状**: 小さな`st.caption`のみ（app.py:754）
- **問題**: 色の意味が分かりにくい
- **影響**: 地点の種類を誤認、選択ミス

**C-4: 実行前検証の不在**
- **現状**: 実行ボタン押下後にエラー表示（app.py:1199-1208）
- **問題**: 事前に問題箇所が分からない
- **影響**: 何度も実行 → エラー → 修正を繰り返す

#### 【D】ページレイアウトの問題

**D-1: 縦長の単一ページ構成**
- **現状**: 全機能が1つのページに縦に配置
- **問題**: スクロールが必須、全体像が見えない
- **影響**: 情報を探す時間が増加、操作ミスが発生

**D-2: セクション区切りの弱さ**
- **現状**: `st.subheader`のみでセクション分割
- **問題**: 視覚的な境界が不明確
- **影響**: 情報のグループ化が分かりにくい

**D-3: サイドバーの未活用**
- **現状**: ネットワーク選択とメタデータ表示のみ（app.py:1012-1041）
- **問題**: 常に表示すべき情報が本文に埋もれている
- **影響**: 状態確認のためにスクロールが必要

#### 【E】入力支援の不足

**E-1: 入力制約の不明確さ**
- **現状**: number_inputに最小値のみ（app.py:326-345）
- **問題**: 単位、推奨値、制約の説明がない
- **影響**: 不適切な値を入力、エラーの原因に

**E-2: リアルタイム検証の欠如**
- **現状**: 実行時まで検証されない
- **問題**: 入力直後にフィードバックがない
- **影響**: 誤った入力に気づかず作業を進める

**E-3: 資源-車種適合の分かりにくさ**
- **現状**: 警告が後から表示される（app.py:356-373）
- **問題**: 選択時点で適合関係が不明
- **影響**: 非適合車種で計画を立ててしまう

### 2.2 ユーザー影響度マトリクス

| 問題ID | 発生頻度 | 影響度 | 修正容易性 | 優先度 |
|--------|----------|--------|------------|--------|
| A-1 | 常時 | 高 | 易 | 最高 |
| A-2 | 常時 | 中 | 易 | 高 |
| A-3 | 頻繁 | 高 | 易 | 最高 |
| B-1 | 常時 | 中 | 中 | 高 |
| B-2 | 頻繁 | 中 | 易 | 中 |
| B-3 | 時々 | 低 | 易 | 低 |
| C-1 | 常時 | 中 | 易 | 高 |
| C-2 | 頻繁 | 高 | 易 | 最高 |
| C-3 | 常時 | 低 | 易 | 中 |
| C-4 | 頻繁 | 高 | 中 | 最高 |
| D-1 | 常時 | 高 | 中 | 高 |
| D-2 | 常時 | 中 | 易 | 中 |
| D-3 | 常時 | 中 | 易 | 高 |
| E-1 | 頻繁 | 中 | 易 | 中 |
| E-2 | 頻繁 | 高 | 中 | 高 |
| E-3 | 頻繁 | 中 | 易 | 中 |

---

## 3. 改善方針

### 3.1 設計原則

1. **段階的改善**: Phase 1→2→3で段階的に実装、各Phaseで動作検証
2. **後方互換性**: セッション状態キー、関数シグネチャを可能な限り維持
3. **最小変更**: ロジックは変更せず、表示とレイアウトのみ変更
4. **視認性優先**: 重要情報は常に見える位置に配置
5. **操作の単純化**: クリック数・スクロール量を削減

### 3.2 改善戦略

| Phase | 焦点 | 所要時間 | 主要改善 |
|-------|------|----------|----------|
| Phase 1 | 情報表示とフィードバック | 1-2時間 | サイドバー活用、実行前チェック |
| Phase 2 | レイアウトと構造 | 2-4時間 | タブ化、情報整理 |
| Phase 3 | 詳細とUX向上 | 2-3時間 | 入力支援、リアルタイム検証 |

---

## 4. 詳細設計

### 4.1 Phase 1: 情報表示とフィードバック強化

#### 改善1-1: サイドバーへの選択状況表示（問題A-1, D-3）

**目的**: 現在の選択状態を常に視認可能にする

**実装箇所**: `main()`関数の冒頭、ネットワーク選択の後

**設計**:
```python
# src/app.py: main()関数内、地図描画前に追加
with st.sidebar:
    st.markdown("---")
    st.subheader("📍 現在の選択状況")

    # 車庫
    depot_display = depot_id if depot_id else "未選択"
    depot_status = "✅" if depot_id else "⚠️"
    st.markdown(f"{depot_status} **車庫**: {depot_display}")

    # 集積場所
    sink_display = sink_id if sink_id else "未選択"
    sink_status = "✅" if sink_id else "⚠️"
    st.markdown(f"{sink_status} **集積場所**: {sink_display}")

    # 回収地点
    pickup_count = len(pickup_selection)
    pickup_status = "✅" if pickup_count > 0 else "⚠️"
    st.markdown(f"{pickup_status} **回収地点**: {pickup_count}箇所")

    # 車種
    vehicle_count = len(vehicles_defined)
    vehicle_status = "✅" if vehicle_count > 0 else "⚠️"
    st.markdown(f"{vehicle_status} **車種候補**: {vehicle_count}種類")
```

**期待効果**:
- スクロール不要で状態確認可能
- 未設定項目が一目で分かる
- 視覚的なチェックリストとして機能

**影響範囲**:
- 既存のst.write("選択状況", {...})は削除または補足情報として残す
- セッション状態への影響なし

---

#### 改善1-2: 実行前チェックリストの追加（問題A-3, C-4）

**目的**: 最適化実行前に全ての必要条件を視覚的に確認

**実装箇所**: 最適化実行ボタンの直前

**設計**:
```python
# src/app.py: 最適化実行ボタンの前に追加
st.markdown("---")
st.subheader("✅ 実行前チェック")

# チェック項目の定義
checks = {
    "車庫が設定されている": depot_id is not None,
    "集積場所が設定されている": sink_id is not None,
    "車庫と集積場所が異なる": depot_id != sink_id if (depot_id and sink_id) else False,
    "回収地点が1箇所以上ある": len(pickup_selection) > 0,
    "全回収地点に資源種別が設定されている": all(
        pickup_id in st.session_state.get("pickup_attrs", {})
        for pickup_id in pickup_selection
    ),
    "車種が1種類以上設定されている": len(vehicles_defined) > 0,
    "車種割当プランが作成されている": len(vehicle_plan) > 0,
    "車種割当に警告がない": len(st.session_state.get("vehicle_filter_warnings", [])) == 0,
}

# チェック結果の表示
all_passed = True
for check_name, passed in checks.items():
    icon = "✅" if passed else "❌"
    color = "normal" if passed else "red"
    st.markdown(f"{icon} {check_name}")
    if not passed:
        all_passed = False

# 実行可否の判定表示
if all_passed:
    st.success("🎉 すべての条件を満たしています。最適化を実行できます。")
else:
    st.error("⚠️ 上記の条件を満たしてから実行してください。")

# 実行ボタン（既存のものを条件付きに変更）
if st.button("最適化を実行", type="primary", disabled=not all_passed):
    # 既存の実行ロジック
```

**期待効果**:
- 実行前に全問題を一覧表示
- ボタンのdisable制御で誤操作防止
- 何を修正すべきか明確化

**影響範囲**:
- 既存の実行ボタンのロジックは維持
- エラーチェックを事前に行うため、実行後のエラーは減少

---

#### 改善1-3: クリックモードの説明追加（問題C-1）

**目的**: 現在のモードで何ができるか明確化

**実装箇所**: クリックモード選択の直後

**設計**:
```python
# src/app.py: mode選択の直後に追加
mode = st.radio("地図クリックモード", ("車庫", "回収地点", "集積場所"), horizontal=True)

# モード別の説明を追加
mode_help = {
    "車庫": "🏠 **車両の出発・帰着地点**を選択してください。地図上でクリックすると最寄りのノードが車庫に設定されます。",
    "回収地点": "📦 **資源を回収する地点**を選択してください。クリック後、資源種別と回収量を入力します。",
    "集積場所": "🏭 **回収した資源を集める場所**を選択してください。回収後、必ずこの地点を経由します。"
}

st.info(mode_help[mode])
```

**期待効果**:
- モードの意味が即座に理解できる
- 次の操作が明確になる
- 誤選択の防止

**影響範囲**:
- 表示のみの追加、ロジックへの影響なし

---

#### 改善1-4: 車種割当プランのデフォルト表示（問題C-2）

**目的**: 重要な割当情報を常に表示

**実装箇所**: 車種割当プラン表示部分

**設計**:
```python
# src/app.py: app.py:1189-1197を修正
if vehicle_plan:
    st.markdown("---")
    st.subheader("📋 車種割当プラン")

    # テーブル形式で表示
    plan_rows = []
    for idx, entry in enumerate(vehicle_plan, start=1):
        vehicle_name = entry.get("vehicle") or "未定義"
        resources = ", ".join(entry.get("resources", [])) or "-"
        pickup_ids = entry.get("pickups", [])
        pickup_count = len(pickup_ids)
        pickup_display = ", ".join(str(p["id"]) for p in pickup_ids[:3])
        if pickup_count > 3:
            pickup_display += f" 他{pickup_count - 3}箇所"

        plan_rows.append({
            "No.": idx,
            "車種": vehicle_name,
            "対応資源": resources,
            "対象地点": pickup_display,
            "地点数": pickup_count
        })

    if pd is not None:
        st.dataframe(pd.DataFrame(plan_rows), hide_index=True, use_container_width=True)
    else:
        for row in plan_rows:
            st.write(f"**{row['No']}. {row['車種']}** - {row['対応資源']} ({row['地点数']}箇所)")

    # 詳細はエクスパンダーに
    with st.expander("📝 割当詳細を表示", expanded=False):
        for idx, entry in enumerate(vehicle_plan, start=1):
            vehicle_name = entry.get("vehicle") or "未定義"
            resources = entry.get("resources", [])
            pickups = entry.get("pickups", [])

            st.markdown(f"### {idx}. {vehicle_name}")
            st.write(f"**対応資源**: {', '.join(resources)}")
            st.write(f"**対象地点**:")
            for p in pickups:
                st.write(f"  - {p['id']}: {p.get('qty', 0)}kg ({p.get('kind', '-')})")
```

**期待効果**:
- 割当プランが常に見える
- 問題があれば即座に気づける
- 詳細情報は必要に応じて展開

**影響範囲**:
- 表示方法の変更のみ
- データ構造は不変

---

#### 改善1-5: 地図凡例の強化（問題C-3）

**目的**: 地図上の色の意味を明確化

**実装箇所**: 地図の直前

**設計**:
```python
# src/app.py: _render_network_map呼び出しの直前
st.markdown("---")
st.subheader("🗺️ 地点選択マップ")

# 凡例を目立つ形で表示
cols = st.columns(4)
cols[0].markdown("🟢 **車庫** (出発/帰着)")
cols[1].markdown("🔵 **回収地点**")
cols[2].markdown("🔴 **集積場所**")
cols[3].markdown("🟡 **最新選択**")

st.caption("💡 地図をクリックして地点を選択できます。現在のモードに応じて地点が設定されます。")
```

**期待効果**:
- 色の意味が一目で分かる
- 操作方法が明確
- ユーザーの迷いを削減

**影響範囲**:
- 表示のみの追加

---

### 4.2 Phase 2: レイアウトと構造の改善

#### 改善2-1: タブ構成の導入（問題D-1, D-2）

**目的**: 作業ステップを明確化し、情報を整理

**実装箇所**: main()関数のメイン部分全体

**設計**:
```python
# src/app.py: main()関数内、地図以降を3つのタブに分割
tab1, tab2, tab3 = st.tabs(["📍 1. 地点選択", "🚗 2. 車種設定", "⚡ 3. 最適化実行"])

with tab1:
    # === 地点選択タブ ===
    st.markdown("### 地図での地点選択")

    # クリックモード選択（改善1-3の内容を含む）
    mode = st.radio(...)
    st.info(mode_help[mode])

    # 地図凡例（改善1-5の内容）
    cols = st.columns(4)
    ...

    # 地図表示
    map_state = _render_network_map(...)

    # クリック処理
    if map_state and map_state.get("last_clicked"):
        # 既存のクリック処理ロジック
        ...

    # ダイアログ表示
    _render_pickup_dialog(processed_master)

    st.markdown("---")
    st.markdown("### 選択済み地点の管理")

    # 回収地点一覧と編集（改善2-3の内容）
    if pickup_selection:
        st.subheader("📦 回収地点一覧")
        # 後述の改善2-3の実装

    # 削除コントロール
    if pickup_selection:
        # 既存の削除UI

    # 手動選択エクスパンダー
    with st.expander("🔧 手動でノードを選択", expanded=False):
        # 既存の手動選択UI

with tab2:
    # === 車種設定タブ ===
    st.markdown("### 車種候補の設定")

    # 車種エディタ（既存の_render_vehicle_editorを呼び出し）
    _render_vehicle_editor(processed_master)

    st.markdown("---")

    # 回収地点の資源種別・数量入力
    if pickup_selection:
        st.markdown("### 回収地点の詳細設定")
        pickup_inputs = _collect_pickup_inputs(pickup_selection, processed_master)
    else:
        st.info("📍 先に「1. 地点選択」タブで回収地点を選択してください。")
        pickup_inputs = []

    st.markdown("---")

    # 車種割当プラン（改善1-4の内容）
    vehicle_plan, plan_warnings = _plan_vehicle_allocations(...)
    if vehicle_plan:
        # 改善1-4の実装

    # 警告表示
    for warning in st.session_state.get("vehicle_filter_warnings", []):
        st.warning(warning, icon="⚠️")

with tab3:
    # === 最適化実行タブ ===
    st.markdown("### 最適化の実行")

    # 実行前チェック（改善1-2の内容）
    st.subheader("✅ 実行前チェック")
    # 改善1-2の実装

    st.markdown("---")

    # 実行ボタン
    if st.button("最適化を実行", type="primary", disabled=not all_passed):
        # 既存の最適化実行ロジック

    st.markdown("---")

    # 結果表示
    stored_solution = st.session_state.get("latest_solution")
    if stored_solution:
        st.markdown("### 最適化結果")
        solution_obj = stored_solution.get("solution")
        plan_summary = stored_solution.get("plan")
        if isinstance(solution_obj, FleetSolution):
            _display_fleet_solution(graph, solution_obj, plan_summary)
        elif isinstance(solution_obj, Solution):
            _display_single_solution(graph, solution_obj)
    else:
        st.info("💡 上記のチェックをすべて満たした後、「最適化を実行」ボタンをクリックしてください。")
```

**期待効果**:
- 作業ステップが明確（地点選択→車種設定→実行）
- 各タブに集中でき、認知負荷が軽減
- スクロールが大幅に削減

**影響範囲**:
- main()関数の構造を大きく変更
- セッション状態キーは不変
- 各処理ロジックは移動のみで変更なし

**移行手順**:
1. 既存コードをコメントアウト
2. タブ構造を作成
3. 各セクションを適切なタブにコピー
4. 動作確認後、コメントアウト部分を削除

---

#### 改善2-2: 車種設定のサイドバー配置（問題A-2）

**目的**: 常に車種情報を確認できるようにする（オプション）

**注意**: タブ構成（改善2-1）と排他的。どちらか一方を選択。

**設計** (タブ構成を採用しない場合):
```python
# src/app.py: サイドバー内に車種設定を移動
with st.sidebar:
    st.markdown("---")
    st.subheader("🚗 車種候補")

    # 簡易表示
    if vehicles_defined:
        for v in vehicles_defined[:3]:  # 最大3件まで表示
            st.caption(f"• {v.name}: {v.capacity_kg}kg")
        if len(vehicles_defined) > 3:
            st.caption(f"... 他{len(vehicles_defined) - 3}種類")
    else:
        st.caption("未設定")

    # 詳細編集はエクスパンダー
    with st.expander("編集", expanded=False):
        _render_vehicle_editor(processed_master)
```

**推奨**: Phase 2ではタブ構成（改善2-1）を優先

---

#### 改善2-3: 回収地点一覧の改善（問題B-1, B-2）

**目的**: 回収地点の確認・編集・削除を一箇所で完結

**実装箇所**: タブ1「地点選択」内

**設計**:
```python
# src/app.py: タブ1内、地図の下
if pickup_selection:
    st.markdown("---")
    st.subheader("📦 選択済み回収地点")

    # 各地点をカード形式で表示
    for idx, point_id in enumerate(pickup_selection, start=1):
        attrs = st.session_state.get("pickup_attrs", {}).get(point_id, {})
        qty = attrs.get("qty", 0)
        resource = attrs.get("resource") or attrs.get("kind", "未設定")

        # エクスパンダーで展開可能
        with st.expander(f"#{idx} {point_id} - {resource} {qty}kg", expanded=False):
            col1, col2, col3 = st.columns([3, 3, 1])

            # 資源種別の再選択
            resource_names = sorted(processed_master.resources.keys()) if processed_master and processed_master.resources else []
            if resource_names:
                try:
                    default_index = resource_names.index(resource)
                except ValueError:
                    default_index = 0
                new_resource = col1.selectbox(
                    "資源種別",
                    resource_names,
                    index=default_index,
                    key=f"edit_resource_{point_id}"
                )
            else:
                new_resource = col1.text_input("資源種別", value=resource, key=f"edit_resource_{point_id}")

            # 数量の再入力
            new_qty = col2.number_input(
                "回収量 (kg)",
                min_value=0,
                value=int(qty),
                step=50,
                key=f"edit_qty_{point_id}"
            )

            # 更新ボタン
            if col1.button("更新", key=f"update_{point_id}"):
                attrs = st.session_state.get("pickup_attrs", {})
                attrs[point_id] = {"qty": int(new_qty), "kind": new_resource, "resource": new_resource}
                st.session_state["pickup_attrs"] = attrs
                st.success(f"✅ {point_id} を更新しました")
                st.rerun()

            # 削除ボタン
            if col3.button("🗑️", key=f"delete_{point_id}", help="この地点を削除"):
                pickups = st.session_state.get("pickup_selection", [])
                if point_id in pickups:
                    pickups.remove(point_id)
                    st.session_state["pickup_selection"] = pickups
                attrs = st.session_state.get("pickup_attrs", {})
                if point_id in attrs:
                    attrs.pop(point_id)
                    st.session_state["pickup_attrs"] = attrs
                st.success(f"🗑️ {point_id} を削除しました")
                st.rerun()

            # 資源情報の表示
            if processed_master and processed_master.resources:
                resource_info = processed_master.resources.get(new_resource)
                if resource_info:
                    summary_lines = _resource_summary(resource_info)
                    if summary_lines:
                        st.caption(" / ".join(summary_lines))

    # 一括削除ボタン
    if st.button("🗑️ すべての回収地点をクリア", key="pickup_clear_all"):
        st.session_state["pickup_selection"] = []
        st.session_state["pickup_attrs"] = {}
        _clear_pending_pickup()
        st.success("🗑️ すべての回収地点を削除しました")
        st.rerun()
else:
    st.info("💡 地図上で回収地点をクリックして追加してください。")
```

**期待効果**:
- 回収地点の一覧、編集、削除が一箇所で完結
- 個別削除が容易
- 現在の設定が一目で分かる

**影響範囲**:
- 既存の`_collect_pickup_inputs`は削除または統合
- セッション状態の更新ロジックは維持

---

### 4.3 Phase 3: 詳細とUX向上

#### 改善3-1: 入力支援の強化（問題E-1）

**目的**: 入力時のガイダンスと制約を明確化

**実装箇所**: ダイアログ、回収地点編集フォーム

**設計**:
```python
# src/app.py: ダイアログ内、_render_pickup_dialog関数
qty = st.number_input(
    "回収量 (kg)",
    min_value=0,
    max_value=100000,  # 上限を設定
    value=max(0, default_qty),
    step=50,
    key=qty_key,
    help="回収する資源の重量をキログラム単位で入力してください。50kg刻みで入力できます。"
)

# 入力値に基づくガイダンス
if qty > 0:
    st.caption(f"💡 入力値: {qty}kg = {qty/1000:.2f}トン")

    # 車種容量との比較
    vehicles = st.session_state.get("vehicles", [])
    if vehicles:
        compatible_count = sum(1 for v in vehicles if v.get("capacity_kg", 0) >= qty)
        if compatible_count > 0:
            st.success(f"✅ {compatible_count}種類の車両で運搬可能です")
        else:
            st.error(f"❌ 現在の車種では容量不足です。車種設定を見直してください。")
```

**期待効果**:
- 入力制約が明確
- 単位変換を自動表示
- 容量との関係が即座に分かる

---

#### 改善3-2: リアルタイム検証（問題E-2）

**目的**: 入力直後にエラーを検出

**実装箇所**: 車種設定、回収地点設定

**設計**:
```python
# src/app.py: _render_vehicle_editor関数内
# st.data_editor の後に検証ロジックを追加

vehicles = st.session_state["vehicles"]

# リアルタイム検証
validation_errors = []
for idx, vehicle in enumerate(vehicles):
    name = vehicle.get("name", "")
    capacity = vehicle.get("capacity_kg", 0)
    fixed_cost = vehicle.get("fixed_cost", 0)
    per_km_cost = vehicle.get("per_km_cost", 0)

    # 名称チェック
    if not name or name.strip() == "":
        validation_errors.append(f"❌ 車種{idx+1}: 名称が未入力です")

    # 容量チェック
    if capacity <= 0:
        validation_errors.append(f"❌ {name}: 容量は1以上を設定してください")

    # コストチェック
    if fixed_cost < 0:
        validation_errors.append(f"❌ {name}: 固定費は0以上を設定してください")
    if per_km_cost < 0:
        validation_errors.append(f"❌ {name}: 距離単価は0以上を設定してください")

    # 重複名称チェック
    duplicate_count = sum(1 for v in vehicles if v.get("name") == name)
    if duplicate_count > 1:
        validation_errors.append(f"⚠️ {name}: 重複した車種名があります")

# エラー表示
if validation_errors:
    st.error("以下の問題を修正してください:")
    for error in validation_errors:
        st.write(error)
else:
    st.success("✅ 車種設定に問題はありません")
```

**期待効果**:
- 入力ミスを即座に発見
- 実行前に問題を解決
- ユーザーの試行錯誤を削減

---

#### 改善3-3: 資源-車種適合の可視化（問題E-3）

**目的**: 選択時点で適合関係を明示

**実装箇所**: 回収地点の資源選択時

**設計**:
```python
# src/app.py: 資源種別選択の直後
if resource_names and processed_master and processed_master.compatibility:
    selected_resource = # 選択された資源
    current_vehicle_names = {record.get("name") for record in st.session_state.get("vehicles", [])}

    # 適合車種の集計
    compatible_vehicles = []
    incompatible_vehicles = []

    for name in current_vehicle_names:
        if not name:
            continue
        compat = processed_master.compatibility.get(name)
        if not compat:
            continue
        status = compat.supports.get(selected_resource)
        if status is True:
            compatible_vehicles.append(name)
        elif status is False:
            incompatible_vehicles.append(name)

    # 適合状況の表示
    if compatible_vehicles:
        st.success(f"✅ 適合車種: {', '.join(sorted(compatible_vehicles))}")

    if incompatible_vehicles:
        st.warning(f"⚠️ 非適合車種: {', '.join(sorted(incompatible_vehicles))}")
        st.caption("💡 この資源は上記の車種では運搬できません。他の車種を追加するか、資源種別を変更してください。")

    if not compatible_vehicles and not incompatible_vehicles:
        st.info("ℹ️ 適合情報がマスタに登録されていません。")
```

**期待効果**:
- 資源選択時点で車種適合が分かる
- 非適合な組み合わせを事前に回避
- 必要な車種追加を促す

---

#### 改善3-4: プログレス表示の追加（UX向上）

**目的**: 長時間処理中の状態を明示

**実装箇所**: 最適化実行中

**設計**:
```python
# src/app.py: 最適化実行ボタンの処理内
if st.button("最適化を実行", type="primary", disabled=not all_passed):
    # 進捗表示
    progress_bar = st.progress(0)
    status_text = st.empty()

    try:
        # ステップ1: 距離行列計算
        status_text.text("📊 距離行列を計算中...")
        progress_bar.progress(25)

        with st.spinner("距離行列を計算中..."):
            distance_matrix = cached_distance_matrix(str(selected_path), tuple(unique_nodes))

        # ステップ2: 車種割当準備
        status_text.text("🚗 車種割当を準備中...")
        progress_bar.progress(50)

        assignments = []  # 既存のロジック

        # ステップ3: 最適化実行
        status_text.text("⚡ 最適化を実行中...")
        progress_bar.progress(75)

        with st.spinner("最適化を実行中..."):
            result = solve_fleet_routing(distance_matrix, depot_id, sink_id, assignments)

        # ステップ4: 完了
        progress_bar.progress(100)
        status_text.text("✅ 完了しました！")

        # 既存の結果処理

    finally:
        # プログレスバーをクリア
        import time
        time.sleep(1)
        progress_bar.empty()
        status_text.empty()
```

**期待効果**:
- 処理状況が視覚的に分かる
- 待ち時間のストレス軽減
- フリーズしていないことを確認できる

---

## 5. 実装計画

### 5.1 Phase別実装順序

#### Phase 1: 情報表示とフィードバック強化 (1-2時間)

**実装順序**:
1. 改善1-1: サイドバーへの選択状況表示 (20分)
2. 改善1-3: クリックモードの説明追加 (15分)
3. 改善1-5: 地図凡例の強化 (10分)
4. 改善1-4: 車種割当プランのデフォルト表示 (20分)
5. 改善1-2: 実行前チェックリストの追加 (30分)
6. 動作確認とバグ修正 (30分)

**検証項目**:
- サイドバーに選択状況が正しく表示される
- 未選択項目に警告マークが表示される
- クリックモード説明が適切に表示される
- 実行前チェックが正しく動作する
- チェック失敗時にボタンがdisableされる

---

#### Phase 2: レイアウトと構造の改善 (2-4時間)

**実装順序**:
1. タブ構造の骨組み作成 (30分)
   - 3つのタブを作成
   - 既存コードをコメントアウト
2. タブ1「地点選択」の実装 (45分)
   - 地図関連コードを移動
   - 改善2-3の回収地点一覧を実装
3. タブ2「車種設定」の実装 (45分)
   - 車種エディタを移動
   - 回収地点詳細設定を配置
   - 車種割当プランを配置
4. タブ3「最適化実行」の実装 (30分)
   - 実行前チェックを移動
   - 実行ボタンと結果表示を配置
5. セッション状態の同期確認 (30分)
6. 動作確認とバグ修正 (60分)

**検証項目**:
- タブ間の遷移が正しく動作する
- セッション状態がタブ間で共有される
- 各タブで期待通りの操作ができる
- 回収地点の個別削除が動作する
- 既存機能がすべて動作する

---

#### Phase 3: 詳細とUX向上 (2-3時間)

**実装順序**:
1. 改善3-1: 入力支援の強化 (45分)
   - ダイアログのヘルプテキスト追加
   - 単位変換表示
   - 容量チェック
2. 改善3-2: リアルタイム検証 (60分)
   - 車種設定の検証
   - 回収地点の検証
   - エラーメッセージの統一
3. 改善3-3: 資源-車種適合の可視化 (30分)
4. 改善3-4: プログレス表示の追加 (30分)
5. 動作確認とバグ修正 (45分)

**検証項目**:
- 入力時にヘルプが表示される
- 検証エラーがリアルタイムで表示される
- 資源-車種適合が正しく表示される
- プログレスバーが適切に動作する

---

### 5.2 マイグレーション戦略

#### ブランチ戦略
```
main (現行)
  ↓
feature/ui-improvement-phase1
  ↓ (merge after verification)
feature/ui-improvement-phase2
  ↓ (merge after verification)
feature/ui-improvement-phase3
  ↓ (merge after verification)
main (改善版)
```

#### ロールバック計画
- 各Phaseでコミット
- 問題発生時は前Phaseにロールバック可能
- 既存コードは最初のコミットで別ファイルにバックアップ

---

## 6. 影響範囲分析

### 6.1 変更ファイル

| ファイル | 変更内容 | 影響度 | リスク |
|---------|---------|--------|--------|
| src/app.py | レイアウト・表示ロジック全面改修 | 高 | 中 |
| src/ui/*.py | 現状は未使用のため影響なし | 低 | 低 |
| src/services/*.py | 変更なし | なし | なし |
| src/infra/*.py | 変更なし | なし | なし |

### 6.2 セッション状態キー

**維持するキー** (変更なし):
- `vehicles`, `vehicle_metadata`
- `pickup_attrs`, `depot_id`, `sink_id`, `pickup_selection`
- `node_coords_cache`, `spatial_index_cache`
- `last_click_token`, `last_selected_node`, `last_selected_role`
- `vehicle_requirements`, `vehicle_filter_warnings`
- `required_resources`, `pending_pickup`, `pending_pickup_defaults`
- `pickup_dialog_open`, `latest_solution`

**新規追加** (Phase 3):
- `validation_errors` (オプション、リアルタイム検証用)

### 6.3 関数シグネチャ

**変更なし**:
- すべてのプライベート関数 (`_*`)
- サービス層の関数

**変更の可能性** (内部構造のみ):
- `main()`: タブ構造導入により内部構造変更、ただしセッション状態は不変

---

## 7. テスト計画

### 7.1 Phase 1 テストケース

#### TC1-1: サイドバー選択状況表示
- **手順**: アプリを起動
- **期待**: サイドバーにすべて「未選択」「⚠️」表示
- **手順**: 車庫を選択
- **期待**: 車庫が「✅」に変化、ノードIDが表示

#### TC1-2: 実行前チェック
- **手順**: 何も設定せずに実行タブを開く
- **期待**: すべて「❌」、実行ボタンがdisabled
- **手順**: 必要項目を順次設定
- **期待**: 設定完了項目が「✅」に変化
- **手順**: すべて設定完了
- **期待**: 実行ボタンが有効化、成功メッセージ表示

#### TC1-3: クリックモード説明
- **手順**: クリックモードを「車庫」「回収地点」「集積場所」と切り替え
- **期待**: 各モードに応じた説明が表示される

#### TC1-4: 車種割当プラン表示
- **手順**: 回収地点と車種を設定
- **期待**: 割当プランがテーブルで常時表示される
- **期待**: 詳細エクスパンダーから詳細情報を確認できる

---

### 7.2 Phase 2 テストケース

#### TC2-1: タブ遷移
- **手順**: タブ1→2→3と遷移
- **期待**: 各タブが正しく表示される
- **手順**: タブ3→1と逆順に遷移
- **期待**: 設定内容が保持されている

#### TC2-2: タブ間のデータ連携
- **手順**: タブ1で回収地点を3箇所追加
- **期待**: サイドバーに「3箇所」表示
- **手順**: タブ2に移動
- **期待**: 3箇所の回収地点が詳細設定に表示される
- **手順**: タブ3に移動
- **期待**: 実行前チェックに反映されている

#### TC2-3: 回収地点個別編集
- **手順**: 回収地点一覧から1箇所のエクスパンダーを開く
- **期待**: 現在の設定値が表示される
- **手順**: 資源種別と数量を変更し「更新」
- **期待**: 変更が反映され、成功メッセージ表示
- **手順**: タブ2で確認
- **期待**: 変更が反映されている

#### TC2-4: 回収地点個別削除
- **手順**: 回収地点一覧から1箇所の「🗑️」をクリック
- **期待**: 削除され、一覧から消える
- **期待**: サイドバーの地点数が減る

---

### 7.3 Phase 3 テストケース

#### TC3-1: 入力支援
- **手順**: ダイアログで回収量に「1000」を入力
- **期待**: 「1000kg = 1.00トン」と表示
- **期待**: 対応可能な車種数が表示される

#### TC3-2: リアルタイム検証（車種）
- **手順**: 車種の容量に「-100」を入力
- **期待**: 即座にエラーメッセージ表示
- **手順**: 「500」に修正
- **期待**: エラーが消え、成功メッセージ表示

#### TC3-3: 資源-車種適合表示
- **手順**: マスタ登録済みの資源を選択
- **期待**: 適合車種と非適合車種が表示される
- **手順**: 非適合車種しかない資源を選択
- **期待**: 警告メッセージとガイダンス表示

#### TC3-4: プログレス表示
- **手順**: 最適化を実行
- **期待**: プログレスバーが0%→25%→50%→75%→100%と進行
- **期待**: 各ステップのステータステキストが表示される

---

### 7.4 回帰テストケース

#### RT1: 既存機能の動作確認
- 地図クリックでの地点選択
- 手動選択での地点設定
- ダイアログでの回収地点追加
- 車種エディタでの追加・削除
- 最適化実行と結果表示
- 結果の地図表示

#### RT2: セッション状態の永続性
- ページ再読み込み後も設定が保持される
- タブ切り替え後も設定が保持される

#### RT3: エッジケース
- 回収地点0箇所での実行試行
- 車種0件での実行試行
- 同一ノードの重複選択試行
- 存在しないノードIDの手動入力

---

## 8. リスクと対策

### 8.1 実装リスク

| リスク | 影響 | 確率 | 対策 |
|--------|------|------|------|
| タブ導入でセッション状態が不整合 | 高 | 中 | 段階的実装、各Phase後に動作確認 |
| 既存ロジックの意図しない破壊 | 高 | 低 | コピペでなく移動、ユニットテスト整備 |
| Streamlitバージョン依存の問題 | 中 | 低 | st.tabsの互換性確認、フォールバック実装 |
| パフォーマンス劣化 | 中 | 低 | リアルタイム検証の最適化、キャッシュ活用 |
| ユーザー混乱（UI変更） | 中 | 中 | 段階的ロールアウト、ドキュメント整備 |

### 8.2 対策詳細

#### 対策1: セッション状態の不整合防止
```python
# 各セッション状態キーのアクセス時に存在確認
depot_id = st.session_state.get("depot_id")
if depot_id is None:
    st.session_state["depot_id"] = None  # デフォルト値設定

# または、初期化関数を確実に呼び出し
def _ensure_session_state():
    """セッション状態の初期化を保証"""
    if "vehicles" not in st.session_state:
        _init_session_state(None)
```

#### 対策2: バージョン互換性の確保
```python
# st.tabsの存在確認とフォールバック
tabs_available = hasattr(st, 'tabs')
if tabs_available:
    tab1, tab2, tab3 = st.tabs(["📍 1. 地点選択", "🚗 2. 車種設定", "⚡ 3. 最適化実行"])
    # タブ実装
else:
    # 従来の縦長レイアウトで実装
    st.markdown("## 📍 1. 地点選択")
    # ...
```

#### 対策3: パフォーマンス最適化
```python
# リアルタイム検証は@st.cache_dataでキャッシュ
@st.cache_data
def _validate_vehicle(vehicle: Dict) -> List[str]:
    """車種設定の検証（キャッシュ可能）"""
    errors = []
    # 検証ロジック
    return errors

# 呼び出し時
errors = _validate_vehicle(frozendict(vehicle))  # 辞書をフリーズして
```

---

## 9. 補足資料

### 9.1 Before/After 比較

#### Before (現状)
```
[タイトル]
  [サイドバー]
    - ネットワーク選択
    - ノード数/エッジ数表示
  [メイン]
    - クリックモード (ラジオボタン)
    - 地図
    - ダイアログ (条件付き)
    - 回収地点削除UI
    - 選択状況 (辞書表示)
    - 手動選択 (エクスパンダー)
    - 車種エディタ
    - 回収地点詳細入力
    - 車種割当プラン (エクスパンダー)
    - 警告 (個別)
    - 実行ボタン
    - 結果表示
```

#### After (改善後)
```
[タイトル]
  [サイドバー]
    - ネットワーク選択
    - ノード数/エッジ数表示
    ---
    - 📍 現在の選択状況 ← NEW
      ✅/⚠️ 車庫: node_xxx
      ✅/⚠️ 集積場所: node_yyy
      ✅/⚠️ 回収地点: 3箇所
      ✅/⚠️ 車種候補: 2種類

  [メイン]
    [タブ1: 地点選択] ← NEW
      - クリックモード + 説明 ← 改善
      - 地図凡例 ← 強化
      - 地図
      - ダイアログ
      - 📦 選択済み回収地点 ← NEW
        - #1 node_aaa - 紙 100kg [編集/削除]
        - #2 node_bbb - プラ 200kg [編集/削除]
      - 🗑️ すべてクリア
      - 🔧 手動選択 (エクスパンダー)

    [タブ2: 車種設定] ← NEW
      - 車種エディタ + リアルタイム検証 ← 改善
      - 回収地点詳細設定
      - 📋 車種割当プラン ← デフォルト表示
      - 警告 (集約)

    [タブ3: 最適化実行] ← NEW
      - ✅ 実行前チェック ← NEW
        ✅/❌ チェック項目1
        ✅/❌ チェック項目2
        ...
      - 実行ボタン (条件付きdisable) ← 改善
      - プログレスバー ← NEW
      - 結果表示
```

### 9.2 用語集

| 用語 | 説明 |
|------|------|
| セッション状態 | Streamlitの`st.session_state`に保存される、ページ再読み込み間で保持されるデータ |
| エクスパンダー | `st.expander`で作成される、展開/折りたたみ可能なUI要素 |
| リアルタイム検証 | ユーザー入力直後に即座に実行される検証処理 |
| 実行前チェック | 最適化実行前に必要条件を満たしているか確認する処理 |
| タブ構成 | `st.tabs`で作成される、複数の画面を切り替え可能にするレイアウト |
| 車種割当プラン | 資源種別と車種の対応関係を示す計画 |

### 9.3 参考資料

- Streamlit公式ドキュメント: https://docs.streamlit.io/
- Streamlit Cheat Sheet: https://docs.streamlit.io/library/cheatsheet
- UIデザインベストプラクティス: Nielsen Norman Group
- 既存設計書: `docs/design.md`, `docs/20251022_1616_map_render_design.md`

---

## 10. 変更履歴

| 日付 | バージョン | 変更内容 | 担当 |
|------|-----------|---------|------|
| 2025-10-23 | 1.0 | 初版作成 | Claude |

---

## 11. 承認

| 役割 | 氏名 | 承認日 | 署名 |
|------|------|--------|------|
| 設計者 | Claude | 2025-10-23 |  |
| レビュアー |  |  |  |
| 承認者 |  |  |  |
