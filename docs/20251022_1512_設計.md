# 資源回収ルート最適化ツール UI/サービス改善設計

## 1. 背景
現行システムは道路ネットワークのノード数が増えるにつれ、以下の課題が顕在化している。
- Folium による地図コンポーネントが Streamlit の再実行ごとに再構築され、約 2,700 個のマーカーを毎回描画するため UI が著しく重くなる。
- Streamlit の状態更新ごとに Folium 生成 HTML/JavaScript ペイロードが再計算・再送され、描画待ち時間が長い。
- 手動セレクター類が全ノードリストを再構築するため、Python 側でのリスト生成/ソートに時間がかかる。
- `_nearest_node` が線形走査で最近傍ノードを探索しており、クリック処理のボトルネックとなりうる。
- サービス層の `snap_to_graph` が未実装に近く、オフネット座標の入力を正しく扱えない。

これらを同時に解決するため、UI 層とサービス層の双方を見直す。

## 2. 目的
1. 地図描画の再負荷を最小化し、クリック応答を 1 秒未満に抑える。
2. ユーザー操作に応じた差分更新のみを行い、不要な HTML/JS 再生成を防ぐ。
3. 手動セレクターを高速化し、ノード数に線形にスケールしないよう改善する。
4. サービス層でオフネット座標を自然に扱えるスナップ機構を整備し、UI 側では簡素な呼出しで済むよう統合する。

## 3. 対応方針概要
- **地図描画:** Folium を継続利用しつつ、ノード群は GeoJSON として一度だけキャッシュし、再描画時は差分レイヤーのみ更新する。必要であれば pydeck への移行オプションも評価する。
- **状態管理:** `st.session_state` に地図データと空間インデックスを保持し、選択更新時は Streamlit の rerun 数を減らすために `st.experimental_rerun` の発火箇所を限定する。
- **セレクター:** キャッシュ済みノード一覧をメモリ内で保持し、手動セレクターには検索ボックス付きの `st.dataframe` / `st.multiselect`（`options` にコールバックを渡す）を利用、あるいは Folium 側で手動選択 UI を補完する。
- **最近傍検索:** 新モジュール（`src/services/spatial_index.py`）で KDTree を構築し、`snap_to_graph` から利用。`scipy.spatial` が利用不可な環境では BallTree 相当を純 Python で実装するフォールバックを提供。
- **サービス層統合:** `snap_to_graph` は `SnappedPoint` にノード ID と接続距離（補正距離）を含める。`DistanceMatrix` は補正距離を起点・終点それぞれに加算し、オフネット地点でも正しいコスト計算が行えるよう改修する。

## 4. 詳細設計

### 4.1 地図描画最適化
- `src/app.py` の `_render_network_map` を分割:
  - `build_base_map(node_coords)` で Folium Map と GeoJSON レイヤーを生成し `st.cache_resource` する。
  - 選択状態（車庫/集積/回収）を描画するオーバーレイのみ都度更新。
- GeoJSON の生成:
  - 全ノード座標を `FeatureCollection` にまとめ、properties に `id`・`name` を付与。
  - `folium.GeoJson` を用いて一度描画し、クリックイベントは GeoJSON の `onEachFeature` で JS 側から node_id を返す。
  - Python 側では `st_folium` の `last_object_clicked` を取得し、`node_id` を受け取る。
- 追加最適化:
  - Marker ではなく CircleMarker のままでも `MarkerCluster` にまとめることで DOM ノード数を削減（ただし cluster 展開までの初期表示コストを計測する）。
  - 将来的に pydeck の ScatterplotLayer へ置換する場合は `st.pydeck_chart` に切り替え、ノードセットは `pandas.DataFrame` で供給する。

### 4.2 Streamlit 状態制御
- マップ再描画を伴う処理は `st.session_state["map_version"]` で管理し、選択対象が変わったときのみインクリメント → `st.experimental_rerun` を明示的に呼ぶ。
- `_init_session_state` に空間インデックス (`spatial_index`) と base map (`base_map_html`) のキャッシュキーを追加。
- `st.radio`・`selectbox` のコールバックに `on_change` を設定し、内部で必要な session_state 更新のみ行う。
- `st_folium` 呼び出し時に `returned_objects=["last_object_clicked"]` を指定し、クリック戻り値を node_id ベースに縮約。

### 4.3 手動セレクター高速化
- `node_ids` を `st.session_state["node_ids"]` に保存し、リスト生成を避ける。
- 手動選択 UI:
  - `st.selectbox` / `st.multiselect` に渡す `options` を事前ソート済みタプルで保持。
  - 検索性を向上するため `st.text_input` でフィルタ語を受け取り、`st.dataframe` で候補を表示。
  - 大量ノード用に “車庫/集積/回収”ごとに最近選択した上位 N 件を優先表示する短いリストを併設。
- 選択結果の `session_state` 反映は差分を検出して必要なときのみ更新。

### 4.4 最近傍検索・スナップ機構
- 新規 `src/services/spatial_index.py`（仮称）を追加: 
  - 関数 `build_kdtree(coords: List[Tuple[float, float]]) -> KDTreeLike`。
  - メソッド `nearest(lat, lon) -> (node_id, distance_m)`。
  - KDTree 実装には `scipy.spatial.KDTree` を優先、インポート失敗時は単純 Grid Index のフォールバック実装（座標を一定距離のセルに分割し線形数を削減）。
- `snap_to_graph` を以下に変更:
  - 入力が `lat`/`lon` のみでも受付。
  - 空間インデックスが未構築なら構築（`st.cache_resource` で node_coords から生成）。
  - 最近傍ノード ID と測地距離（ハバースイン）を返却。
  - 返却する `SnappedPoint` に新フィールド `connector_distance_m` を追加。
- `DistanceMatrix` 改修:
  - ノード距離算出後に、起点/終点の `connector_distance_m` を距離に加算。
  - `node_lookup` に加えて `connector_distance_lookup` を保持。
- UI 側の `_nearest_node` は削除し、`snap_to_graph` を直接呼び出す。

### 4.5 データフロー変更
1. 起動時に graph をロード → `node_coords` 抽出。
2. `spatial_index` を構築し `session_state` に保持。
3. ユーザーが地図をクリックすると、JS から緯度経度 or node_id が返る。
4. `snap_to_graph` が最寄ノード情報を返し、`PointRegistry` に登録。
5. 距離行列作成時には `SnappedPoint` を渡し、connector 距離も含む総距離を算出。
6. ルート表示時には元のクリック座標も保持し、フォリウムに補助ライン（ノードまでの接続線）を描く。

### 4.6 互換性と移行
- 既存の JSON シナリオ（node_id 前提）はそのまま有効。`snap_to_graph` は `osmid/node_id` を指定した入力をそのまま返す。
- 新規に `lat/lon` だけを受け取る API を追加しても既存テストを壊さない。
- 追加するフィールド (`connector_distance_m`) が None の場合は 0 として扱うため、既存コードとの互換性が保たれる。

## 5. 実装ステップ案
1. Spatial Index / snap_to_graph 改修とテスト追加。
2. DistanceMatrix の connector 距離対応、既存テストの調整。
3. UI の最近傍処理をサービス層呼出しに切り替える。
4. Folium base map キャッシュ導入と GeoJSON レイヤー分離。
5. 手動セレクター最適化と UI テスト更新。
6. 全体動作確認（実際のネットワーク JSON を利用してパフォーマンス計測）。

## 6. テスト計画
- `tests/services/test_distance_matrix.py` に SnappedPoint の connector 距離を含めたケースを追加。
- `tests/services/test_optimizer.py` にオフネット座標を使った総距離検証ケースを追加。
- 新規 `tests/services/test_spatial_index.py` で KDTree フォールバック挙動を確認。
- UI 側は Streamlit のスナップショットテスト（`script_runner`）で map クリック → 最近傍ノード更新が 1 rerun で完了することを確認。
- パフォーマンス観測: `pytest` とは別にベンチマークスクリプト (`scripts/profile_map.py`) で GeoJSON 生成時間と rerun 時間を測定。

## 7. リスクと対応
- **Folium × Streamlit API 変更リスク:** `st_folium` の返り値仕様に依存するため、バージョン差異を吸収するラッパーを `ui.map_panel` に用意。
- **KDTree 依存ライブラリ不足:** SciPy 不在の場合を想定したフォールバック実装を提供。
- **GeoJSON サイズ肥大化:** ノード数がさらに増えた場合は、GeoJSON を gzip 圧縮して配信する検討を残課題とする。

## 8. 今後の拡張余地
- PyDeck への完全移行により、WebGL ベースで 1 万ノード規模までスケール可能。
- スナップ結果を実データベースに保存し、複数ユーザー環境での共有を可能にする。
- オフネットコストを車種別に設定する（未舗装路の追加コストなど）。
