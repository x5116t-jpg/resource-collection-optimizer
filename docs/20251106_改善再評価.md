# 描画・最近傍探索・データ構造再評価メモ (2025-11-06)

## 1. 地図描画手段の比較と方針
現行は `src/app.py` の `_render_network_map` で Folium + streamlit-folium を使用している。ノード数は 2,703 件（`data/road_network_20251017_154630.json`）で、リランのたびに全マーカーを Leaflet DOM として再描画している。

### Folium 継続案
- **利点**: 既存のクリック処理（`last_clicked`）と CircleMarker 描画をそのまま流用できる。ルート描画のポリライン再利用も容易。
- **既知の問題**: 大量マーカーで DOM が肥大化し、再実行ごとに iframe を再生成するため遅延が大きい。
- **改善策**
  1. `folium.plugins.FastMarkerCluster` でノード群をクラスタ化して DOM 数を削減する。初期ロードの JS サイズが増えるため、計測で 1,000〜3,000 件のパフォーマンスを確認する。
  2. ノード集合を `folium.GeoJson` に変換し、`folium.GeoJsonTooltip` を活用する。GeoJSON を gzip でプレ生成し（`Path` でキャッシュ）、`st.components.v1.html` に埋め込むことで Streamlit のリラン時にも HTML を使い回す。
  3. クリックイベントは GeoJSON の `on_each_feature` により `feature.id` を `window.parent.postMessage` で Streamlit 側へ返し、`streamlit_folium` ではなく `st.components.v1.html` + `st.session_state` で受け取る。これにより `st_folium` の rerender を抑制できる。

### Pydeck (WebGL) 置換案
- **利点**: WebGL により 1 万件規模でもレスポンスが良い。`ScatterplotLayer` や `PathLayer` でノード・ルートをまとめて描画可能。
- **障害**: `st.pydeck_chart` は現行 (Streamlit 1.39 系) でクリックイベントを直接取得できない。Mapbox API key の管理、アイコン・ツールチップの実装を追加する必要がある。また既存の Folium ベースのルート再描画ロジックを全面的に書き換えることになる。

### 結論
- **短期** (次リリース): Folium を継続しつつ、上記 1〜3 の改善を段階導入。特にクラスタ化 + GeoJSON 生成の分離で初期ロードを削減する。
- **中期**: Streamlit 側で pydeck の pick イベントが安定した場合、`st.pydeck_chart` への移行を再検討。移行前にプロトタイプでクリック補足が課題にならないことを確認する。

## 2. 最近傍探索の軽量高速化
`srv/app.py` の `_nearest_node` は単純線形走査で、中規模 (2,703 ノード) では操作レスポンスに影響する。SciPy など重い依存には頼らず、以下の方針を推奨する。

### 2.1 NumPy ベクトル化案
- `numpy` が利用可能なら、ノード座標を 2 次元配列として保持し、クリック時にベクトル化したハバースイン距離を一括計算する。最小値探索は `numpy.argmin`。
- 依存対策: `numpy` をオプション依存として `requirements-opt.txt` 等で管理し、未導入環境ではフォールバック（次項）に切り替える。

### 2.2 単純グリッドインデックス案（純 Python）
- 緯度経度を一定幅（例: 0.005 度 ≒ 500m）のセルに割り当て、クリック地点と周囲 3×3 セルのノードのみを探索する。
- 200 件のランダム座標を使った簡易ベンチマーク結果（WSL/CPython 3.10）:
  - 線形走査: 約 0.195 秒/100 クエリ
  - グリッド法: 約 0.113 秒/100 クエリ
- 実装方針:
  1. 初期化時に `Dict[(int, int), List[int]]` でセル→ノードインデックスを構築。
  2. 近傍セルに候補がない場合はセルサイズを広げる or 全探索へフォールバック。
  3. `@st.cache_resource` で再利用し、クリック処理ではインデックスだけを参照。

### 2.3 効果測定
- `scripts/profile_spatial_index.py` を新設し、ランダムサンプルまたは実際のクリック履歴で処理時間を記録。
- 目標: 1 クリックあたり 5ms 未満（100 クエリで 0.5 秒以下）。

## 3. 距離行列キャッシュと PointRegistry の再設計
オフネット座標対応（コネクタ距離加算）を見据えて、現行の `build_distance_matrix` キャッシュと `PointRegistry` を以下のように調整する。

### 3.1 SnappedPoint 拡張
- `SnappedPoint` に `connector_distance_m` と `original_latlon` を追加。
- `snap_to_graph` は (lat, lon) 入力時に最近傍ノードと補正距離を計算。
- `PointRegistry` には原点座標とノード ID 両方を保持できるよう、`Point` に `node_id` と `connector_distance_m` を追加する。

### 3.2 距離行列キャッシュキー
- 現在の `cached_distance_matrix(json_path, node_ids)` はノード ID のみでキャッシュしているため、同一ノード ID でもコネクタ距離が異なるケースを識別できない。
- 改修案:
  - キャッシュキーを `(json_path, tuple(sorted((point_id, node_id, round(connector_distance_m, 2)))))` とする。
  - あるいはコネクタ距離を別途 `DistanceMatrix` へ後付け加算し、ノードペア距離は純粋にグラフ距離のみに限定する（推奨）。
  - 後者の場合、`DistanceMatrix` に `connector_offsets: Dict[str, float]` を保持し、`distance(from, to)` で `connector_offsets[from] + matrix[...] + connector_offsets[to]` を返す。

### 3.3 PointRegistry の責務見直し
- 新たに `SnappedPoint` を保持し、UI から渡されたクリック座標を `registry.register_raw_point(lat, lon, type)` → `snap_to_graph` で内包するフローへ変更。
- `registry.list_points()` はノード ID ベースの情報に加え、オフネット距離・元座標を返却できるようにする。
- 永続化を行う場合、補正距離と元座標を含む JSON スキーマを定義する。

### 3.4 マイグレーション・テスト
- `tests/services/test_distance_matrix.py` に、`connector_offsets` を加算した期待値を検証するケースを追加。
- `tests/services/test_spatial_index.py` でグリッド/ベクトル化の両実装をテスト（利用可能な依存のみ実行）。
- 既存 JSON シナリオとの互換性を保つため、`snap_to_graph` に node_id 直接指定の場合は `connector_distance_m=0` で生成する。

---
以上。
